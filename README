PROYECTO FINAL – SISTEMAS OPERATIVOS
Implementación de Scheduler MLFQ en xv6-riscv

DESCRIPCIÓN GENERAL DEL PROYECTO

Este proyecto modifica el sistema operativo educativo xv6-riscv para reemplazar su scheduler original (Round Robin) con un planificador Multi-Level Feedback Queue (MLFQ).
El objetivo es gestionar procesos según su comportamiento real (CPU-bound o IO-bound), asignando distintos niveles de prioridad y quantums de ejecución.

El proyecto incluye además un programa de usuario, test_adv, diseñado para evidenciar el funcionamiento correcto del MLFQ mediante la comparación entre procesos CPU-bound y IO-bound.

CARACTERÍSTICAS PRINCIPALES IMPLEMENTADAS

A. Scheduler MLFQ (3 niveles)

Cola 0: prioridad alta, quantum = 1 tick (procesos interactivos o IO-bound).

Cola 1: prioridad media, quantum = 2 ticks.

Cola 2: prioridad baja, quantum = 5 ticks (procesos CPU-bound).

Comportamiento implementado:

Los procesos que consumen todo su quantum descienden de prioridad.

Los procesos que ceden CPU voluntariamente (IO-bound) permanecen en niveles altos.

El scheduler recorre las colas desde la más alta hasta la más baja.

Cada proceso tiene campos adicionales: queue, ticks_run, y slice_expired.

Este comportamiento reproduce la filosofía del algoritmo MLFQ real:
premiar procesos interactivos y castigar procesos que monopolizan CPU.

TEST AVANZADO: test_adv

El archivo test_adv.c lanza varios procesos:

3 procesos CPU-bound que ejecutan únicamente cómputo intensivo.

3 procesos IO-bound que simulan espera constante usando sleep_fake().

El propósito del test es mostrar en ejecución:

Los CPU-bound terminan rápido (pocos ticks).

Los IO-bound permanecen ejecutándose durante miles de ticks.

Esta diferencia clara demuestra que el MLFQ está funcionando como debe.

RESULTADOS ESPERADOS DEL TEST

CPU-Bound (ej. procesos 4, 5, 6):

Tiempos muy bajos: entre 10 y 20 ticks.

Consumen CPU sin cederla.

El MLFQ los degrada a colas de menor prioridad.

IO-Bound (ej. procesos 7, 8, 9):

Tiempos muy altos: entre 6500 y 6700 ticks.

Ceden CPU constantemente.

El MLFQ mantiene su prioridad alta y por eso viven más tiempo.

Este contraste entre tiempos pequeños y enormes es exactamente lo que predice el MLFQ y confirma que la implementación es correcta.

ESTRUCTURA DEL PROYECTO

xv6-riscv/
kernel/
proc.c (Implementación del MLFQ)
proc.h (Nuevos campos del proceso)
trap.c (Manejo de interrupción del temporizador)
defs.h (Declaración de funciones nuevas)

user/
test_adv.c (Test avanzado del scheduler)

EJECUCIÓN DEL PROYECTO CON DOCKER + QEMU

A. Crear y levantar un contenedor Linux:

docker run -it --name xv6 --privileged -v "${PWD}:/xv6" ubuntu:22.04 bash

B. Instalar dependencias dentro del contenedor:

apt update
apt install -y build-essential git qemu-system-misc gcc-riscv64-linux-gnu make

C. Ir al directorio del proyecto:

cd /xv6

D. Compilar xv6:

make clean
make qemu

E. Ejecutar el test dentro de xv6:

test_adv


